diff --git a/modules/drivers/canbus/can_client/BUILD b/modules/drivers/canbus/can_client/BUILD
index 27f1613..26f59e5 100644
--- a/modules/drivers/canbus/can_client/BUILD
+++ b/modules/drivers/canbus/can_client/BUILD
@@ -20,8 +20,8 @@ cc_library(
         "//modules/drivers/canbus/common:canbus_common",
         "//modules/drivers/canbus/proto:canbus_proto",
     ] + select({
-        "//tools/platforms:use_esd_can": [
-            "//modules/drivers/canbus/can_client/esd:esd_can_client",
+        "//tools/platforms:use_ax_can": [
+            "//modules/drivers/canbus/can_client/axcan:axcan_client",
         ],
         "//conditions:default": [],
     }),
diff --git a/modules/drivers/canbus/can_client/axcan/BUILD b/modules/drivers/canbus/can_client/axcan/BUILD
new file mode 100644
index 0000000..8bef6b8
--- /dev/null
+++ b/modules/drivers/canbus/can_client/axcan/BUILD
@@ -0,0 +1,33 @@
+load("//tools:cpplint.bzl", "cpplint")
+
+package(default_visibility = ["//visibility:public"])
+
+cc_library(
+    name = "axcan_client",
+    srcs = [
+        "axcan_client.cc",
+    ],
+    hdrs = [
+        "axcan_client.h",
+    ],
+    deps = [
+        "//modules/drivers/canbus/can_client",
+        "//third_party/can_card_library/axcan",
+    ],
+)
+
+cc_test(
+    name = "axcan_client_test",
+    size = "small",
+    srcs = [
+        "axcan_client_test.cc",
+    ],
+    deps = [
+        "//cyber",
+        "//modules/drivers/canbus/can_client/axcan:axcan_client",
+        "//modules/drivers/canbus/common:canbus_common",
+        "@gtest//:gtest_main",
+    ],
+)
+
+cpplint()
diff --git a/modules/drivers/canbus/can_client/axcan/axcan_client.cc b/modules/drivers/canbus/can_client/axcan/axcan_client.cc
new file mode 100644
index 0000000..ec5f447
--- /dev/null
+++ b/modules/drivers/canbus/can_client/axcan/axcan_client.cc
@@ -0,0 +1,272 @@
+/******************************************************************************
+ * Copyright 2017 The Apollo Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *****************************************************************************/
+
+/**
+ * @file ax_can_client.cc
+ * @brief the encapsulate call the api of axcan card according to can_client.h
+ *interface
+ **/
+
+#include "modules/drivers/canbus/can_client/axcan/axcan_client.h"
+
+namespace apollo {
+namespace drivers {
+namespace canbus {
+namespace can {
+
+using apollo::common::ErrorCode;
+
+bool AxCanClient::Init(const CANCardParameter &parameter) {
+  if (parameter.has_baud_rate()) {
+    baud_rate_ = parameter.baud_rate();
+  } else {
+    baud_rate_ = CANCardParameter::BAUD_RATE_500;
+  }
+
+  if (!parameter.has_channel_id()) {
+    AERROR << "Init CAN failed: parameter does not have channel id. The "
+              "parameter is "
+           << parameter.DebugString();
+    return false;
+  }
+  port_ = parameter.channel_id();
+  return true;
+}
+
+AxCanClient::~AxCanClient() {
+  if (dev_handler_) {
+    Stop();
+  }
+}
+
+ErrorCode AxCanClient::Start() {
+  if (is_started_) {
+    return ErrorCode::OK;
+  }
+
+  // open device
+  // guss net is the device minor number, if one card is 0,1
+  // if more than one card, when install driver u can specify the minior id
+  // int32_t ret = axcan_open(net, pCtx->mode, txbufsize, rxbufsize, 0, 0,
+  // &dev_handler_);
+  uint32_t mode = 0;
+  // mode |= AXCAN_MODE_NO_RTR;
+  if (port_ > MAX_CAN_PORT || port_ < 0) {
+    AERROR << "can port number [" << port_ << "] is out of the range [0,"
+           << MAX_CAN_PORT << "]";
+    return ErrorCode::CAN_CLIENT_ERROR_BASE;
+  }
+  int32_t ret = axcan_open(port_, mode, 5, 5, &dev_handler_);
+  if (ret != AXCAN_OK) {
+    AERROR << "open device error code [" << ret << "]: " << GetErrorString(ret);
+    return ErrorCode::CAN_CLIENT_ERROR_BASE;
+  }
+  AERROR << "axcan_open() success";
+
+  // init config and state
+  // After a CAN handle is created with axcan_open() the CAN-ID filter is
+  // cleared
+  // (no CAN messages
+  // will pass the filter). To receive a CAN message with a certain CAN-ID
+  // or an
+  // AXCAN-Event with
+  // a certain Event-ID it is required to enable this ID in the handle
+  // filter as
+  // otherwise a
+  // received  message or event is discarded by the driver for this handle.
+  // 1. set receive message_id filter, ie white list
+#if 0
+  int32_t id_count = 1 << 11;
+  ret = axcan_add_filter(dev_handler_, 0, &id_count);
+  if (ret != AXCAN_OK) {
+    AERROR << "add receive msg sff id filter error code: " << ret << ", "
+           << GetErrorString(ret);
+    return ErrorCode::CAN_CLIENT_ERROR_BASE;
+  }
+
+  id_count = 1 << 29;
+  ret = axcan_add_filter(dev_handler_, AXCAN_20B_BASE, &id_count);
+  if (ret != AXCAN_OK) {
+    AERROR << "add receive msg eff id filter error code: " << ret << ", "
+           << GetErrorString(ret);
+    return ErrorCode::CAN_CLIENT_ERROR_BASE;
+  }
+#endif
+
+  // 2. set baudrate
+  switch (baud_rate_) {
+    case CANCardParameter::BAUD_RATE_500: {
+      ret = axcan_set_baudrate(dev_handler_, AXCAN_BAUDRATE_500K);
+      break;
+    }
+    case CANCardParameter::BAUD_RATE_250: {
+      ret = axcan_set_baudrate(dev_handler_, AXCAN_BAUDRATE_250K);
+      break;
+    }
+    default:
+      break;
+  }
+  if (ret != AXCAN_OK) {
+    AERROR << "set baudrate error code: " << ret << ", " << GetErrorString(ret);
+    return ErrorCode::CAN_CLIENT_ERROR_BASE;
+  }
+  AERROR << "axcan_set_baudrate() success";
+
+  ret = axcan_start(dev_handler_);
+  AERROR << "axcan_start() success";
+  is_started_ = true;
+  return ErrorCode::OK;
+}
+
+void AxCanClient::Stop() {
+  if (is_started_) {
+    is_started_ = false;
+    int32_t ret = axcan_close(dev_handler_);
+    if (ret != AXCAN_OK) {
+      AERROR << "close error code:" << ret << ", " << GetErrorString(ret);
+    } else {
+      AINFO << "close ax can ok. port:" << port_;
+    }
+    AERROR << "axcan_close() success";
+  }
+}
+
+// Synchronous transmission of CAN messages
+ErrorCode AxCanClient::Send(const std::vector<CanFrame> &frames,
+                             int32_t *const frame_num) {
+  CHECK_NOTNULL(frame_num);
+  CHECK_EQ(frames.size(), static_cast<size_t>(*frame_num));
+
+  if (!is_started_) {
+    AERROR << "Ax can client has not been initiated! Please init first!";
+    return ErrorCode::CAN_CLIENT_ERROR_SEND_FAILED;
+  }
+  for (size_t i = 0; i < frames.size() && i < MAX_CAN_SEND_FRAME_LEN; ++i) {
+    send_frames_[i].id = frames[i].id & CANID_EFF_FLAG
+                             ? (frames[i].id & CANID_EFF_MASK) | AXCAN_20B_BASE
+                             : frames[i].id & CANID_SFF_MASK;
+    send_frames_[i].len = frames[i].len;
+    std::memcpy(send_frames_[i].data, frames[i].data, frames[i].len);
+  }
+
+  // Synchronous transmission of CAN messages
+  int32_t ret = axcan_send(dev_handler_, send_frames_, *frame_num);
+  if (ret < 0) {
+    AERROR << "send message failed, error code: " << ret << ", "
+           << ret; // << GetErrorString(ret);
+    return ErrorCode::CAN_CLIENT_ERROR_BASE;
+  }
+  return ErrorCode::OK;
+}
+
+// buf size must be 8 bytes, every time, we receive only one frame
+ErrorCode AxCanClient::Receive(std::vector<CanFrame> *const frames,
+                                int32_t *const frame_num) {
+  if (!is_started_) {
+    AERROR << "Ax can client is not init! Please init first!";
+    return ErrorCode::CAN_CLIENT_ERROR_RECV_FAILED;
+  }
+
+  if (*frame_num > MAX_CAN_RECV_FRAME_LEN || *frame_num < 0) {
+    AERROR << "recv can frame num not in range[0, " << MAX_CAN_RECV_FRAME_LEN
+           << "], frame_num:" << *frame_num;
+    // TODO(Authors): check the difference of returning frame_num/error_code
+    return ErrorCode::CAN_CLIENT_ERROR_FRAME_NUM;
+  }
+
+  const int32_t ret = axcan_recv(dev_handler_, recv_frames_, *frame_num);
+  // rx timeout not log
+  if (ret == AXCAN_RX_TIMEOUT) {
+    return ErrorCode::OK;
+  }
+  if (ret < 0) {
+    AERROR << "receive message failed, error code: " << ret << ", "
+           << GetErrorString(ret);
+    return ErrorCode::CAN_CLIENT_ERROR_BASE;
+  }
+
+  *frame_num = ret;
+  for (int32_t i = 0; i < *frame_num && i < MAX_CAN_RECV_FRAME_LEN; ++i) {
+    CanFrame cf;
+    cf.id = recv_frames_[i].id & AXCAN_20B_BASE
+                ? (recv_frames_[i].id & CANID_EFF_MASK) | CANID_EFF_FLAG
+                : recv_frames_[i].id & CANID_SFF_MASK;
+    cf.len = recv_frames_[i].len;
+    std::memcpy(cf.data, recv_frames_[i].data, recv_frames_[i].len);
+    frames->push_back(cf);
+  }
+
+  return ErrorCode::OK;
+}
+
+/************************************************************************/
+/************************************************************************/
+/* Function: GetErrorString()                                            */
+/* Return ASCII representation of AXCAN return code                     */
+/************************************************************************/
+/************************************************************************/
+const int32_t ERROR_BUF_SIZE = 200;
+std::string AxCanClient::GetErrorString(const int axcan_status) {
+  struct ERR2STR {
+    int axcan_status;
+    const char *str;
+  };
+
+  int8_t str_buf[ERROR_BUF_SIZE];
+
+  static const struct ERR2STR err2str[] = {
+      {AXCAN_OK, "AXCAN_OK"},
+      {AXCAN_RX_TIMEOUT, "AXCAN_RX_TIMEOUT"},
+      {AXCAN_TX_TIMEOUT, "AXCAN_TX_TIMEOUT"},
+      {(int)0xffffffff, "AXCAN_UNKNOWN"} /* stop-mark */
+  };
+
+  const struct ERR2STR *es = err2str;
+
+  do {
+    if (es->axcan_status == axcan_status) {
+      break;
+    }
+    es++;
+  } while ((uint32_t)es->axcan_status != 0xffffffff);
+
+#ifdef AXCAN_ERROR_FORMAT_LONG
+  {
+    int res;
+    char sz_error_text[60];
+
+    res = canFormatError(axcan_status, AXCAN_ERROR_FORMAT_LONG, sz_error_text,
+                         static_cast<uint32_t>(sizeof(sz_error_text) - 1));
+    if (AXCAN_OK == res) {
+      snprintf(reinterpret_cast<char *>(str_buf), ERROR_BUF_SIZE, "%s - %s",
+               es->str, sz_error_text);
+    } else {
+      snprintf(reinterpret_cast<char *>(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
+               es->str, axcan_status);
+    }
+  }
+#else
+  snprintf(reinterpret_cast<char *>(str_buf), ERROR_BUF_SIZE, "%s(0x%08x)",
+           es->str, axcan_status);
+#endif /* of AXCAN_ERROR_FORMAT_LONG */
+  return std::string((const char *)(str_buf));
+}
+
+}  // namespace can
+}  // namespace canbus
+}  // namespace drivers
+}  // namespace apollo
+
diff --git a/modules/drivers/canbus/can_client/axcan/axcan_client.h b/modules/drivers/canbus/can_client/axcan/axcan_client.h
new file mode 100644
index 0000000..8abd5e0
--- /dev/null
+++ b/modules/drivers/canbus/can_client/axcan/axcan_client.h
@@ -0,0 +1,113 @@
+/******************************************************************************
+ * Copyright 2017 The Apollo Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *****************************************************************************/
+
+/**
+ * @file
+ * @brief Defines the AxCanClient class which inherits CanClient.
+ */
+
+#pragma once
+
+#include <string>
+#include <vector>
+
+#include "axcan/include/axcan.h"
+#include "gflags/gflags.h"
+
+#include "modules/common/proto/error_code.pb.h"
+#include "modules/drivers/canbus/proto/can_card_parameter.pb.h"
+
+#include "modules/drivers/canbus/can_client/can_client.h"
+#include "modules/drivers/canbus/common/canbus_consts.h"
+
+/**
+ * @namespace apollo::drivers::canbus::can
+ * @brief apollo::drivers::canbus::can
+ */
+namespace apollo {
+namespace drivers {
+namespace canbus {
+namespace can {
+
+/**
+ * @class AxCanClient
+ * @brief The class which defines a AXCAN client which inherits CanClient.
+ */
+class AxCanClient : public CanClient {
+ public:
+  /**
+   * @brief Initialize the AXCAN client by specified CAN card parameters.
+   * @param parameter CAN card parameters to initialize the CAN client.
+   * @return If the initialization is successful.
+   */
+  bool Init(const CANCardParameter &parameter) override;
+
+  /**
+   * @brief Destructor
+   */
+  virtual ~AxCanClient();
+
+  /**
+   * @brief Start the AXCAN client.
+   * @return The status of the start action which is defined by
+   *         apollo::common::ErrorCode.
+   */
+  apollo::common::ErrorCode Start() override;
+
+  /**
+   * @brief Stop the AXCAN client.
+   */
+  void Stop() override;
+
+  /**
+   * @brief Send messages
+   * @param frames The messages to send.
+   * @param frame_num The amount of messages to send.
+   * @return The status of the sending action which is defined by
+   *         apollo::common::ErrorCode.
+   */
+  apollo::common::ErrorCode Send(const std::vector<CanFrame> &frames,
+                                 int32_t *const frame_num) override;
+
+  /**
+   * @brief Receive messages
+   * @param frames The messages to receive.
+   * @param frame_num The amount of messages to receive.
+   * @return The status of the receiving action which is defined by
+   *         apollo::common::ErrorCode.
+   */
+  apollo::common::ErrorCode Receive(std::vector<CanFrame> *const frames,
+                                    int32_t *const frame_num) override;
+
+  /**
+   * @brief Get the error string.
+   * @param status The status to get the error string.
+   */
+  std::string GetErrorString(const int32_t status) override;
+
+ private:
+  AXCAN_HANDLE dev_handler_;
+  CANCardParameter::CANChannelId port_;
+  CANCardParameter::CANBaudRate baud_rate_;
+  axcan_msg_t send_frames_[MAX_CAN_SEND_FRAME_LEN];
+  axcan_msg_t recv_frames_[MAX_CAN_RECV_FRAME_LEN];
+};
+
+}  // namespace can
+}  // namespace canbus
+}  // namespace drivers
+}  // namespace apollo
+
diff --git a/modules/drivers/canbus/can_client/axcan/axcan_client_test.cc b/modules/drivers/canbus/can_client/axcan/axcan_client_test.cc
new file mode 100644
index 0000000..226906c
--- /dev/null
+++ b/modules/drivers/canbus/can_client/axcan/axcan_client_test.cc
@@ -0,0 +1,56 @@
+/******************************************************************************
+ * Copyright 2017 The Apollo Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *****************************************************************************/
+
+#include "modules/drivers/canbus/can_client/axcan/axcan_client.h"
+
+#include <vector>
+
+#include "gtest/gtest.h"
+
+#include "modules/drivers/canbus/proto/can_card_parameter.pb.h"
+
+namespace apollo {
+namespace drivers {
+namespace canbus {
+namespace can {
+
+using apollo::common::ErrorCode;
+
+TEST(AxCanClientTest, simple_test) {
+  CANCardParameter param;
+  param.set_brand(CANCardParameter::AX_CAN);
+  param.set_channel_id(CANCardParameter::CHANNEL_ID_ZERO);
+
+  AxCanClient ax_can_client;
+  EXPECT_TRUE(ax_can_client.Init(param));
+  EXPECT_EQ(ax_can_client.Start(), ErrorCode::CAN_CLIENT_ERROR_BASE);
+  std::vector<CanFrame> frames;
+  int32_t num = 0;
+  EXPECT_EQ(ax_can_client.Send(frames, &num),
+            ErrorCode::CAN_CLIENT_ERROR_SEND_FAILED);
+  EXPECT_EQ(ax_can_client.Receive(&frames, &num),
+            ErrorCode::CAN_CLIENT_ERROR_RECV_FAILED);
+  CanFrame can_frame;
+  frames.push_back(can_frame);
+  EXPECT_EQ(ax_can_client.SendSingleFrame(frames),
+            ErrorCode::CAN_CLIENT_ERROR_SEND_FAILED);
+  ax_can_client.Stop();
+}
+
+}  // namespace can
+}  // namespace canbus
+}  // namespace drivers
+}  // namespace apollo
diff --git a/modules/drivers/canbus/can_client/can_client_factory.cc b/modules/drivers/canbus/can_client/can_client_factory.cc
index e2a226a..822aefb 100644
--- a/modules/drivers/canbus/can_client/can_client_factory.cc
+++ b/modules/drivers/canbus/can_client/can_client_factory.cc
@@ -20,6 +20,9 @@
 #if USE_ESD_CAN
 #include "modules/drivers/canbus/can_client/esd/esd_can_client.h"
 #endif
+#if USE_AX_CAN
+#include "modules/drivers/canbus/can_client/axcan/axcan_client.h"
+#endif
 
 #include "cyber/common/log.h"
 #include "modules/common/util/util.h"
@@ -41,6 +44,11 @@ void CanClientFactory::RegisterCanClients() {
   Register(CANCardParameter::ESD_CAN,
            []() -> CanClient* { return new can::EsdCanClient(); });
 #endif
+#if USE_AX_CAN
+  AINFO << "register can: " << CANCardParameter::AX_CAN;
+  Register(CANCardParameter::AX_CAN,
+           []() -> CanClient* { return new can::AxCanClient(); });
+#endif
   Register(CANCardParameter::SOCKET_CAN_RAW,
            []() -> CanClient* { return new can::SocketCanClientRaw(); });
 
diff --git a/modules/drivers/canbus/can_client/can_client_factory_test.cc b/modules/drivers/canbus/can_client/can_client_factory_test.cc
index 8f2a70e..0d13ebd 100644
--- a/modules/drivers/canbus/can_client/can_client_factory_test.cc
+++ b/modules/drivers/canbus/can_client/can_client_factory_test.cc
@@ -38,6 +38,14 @@ TEST(CanClientFactoryTest, CreateCanClient) {
 
   EXPECT_TRUE(can_factory->CreateCANClient(can_card_parameter) != nullptr);
 #endif
+#if USE_AX_CAN
+  CANCardParameter can_card_parameter;
+  can_card_parameter.set_brand(CANCardParameter::AX_CAN);
+  can_card_parameter.set_type(CANCardParameter::PCI_CARD);
+  can_card_parameter.set_channel_id(CANCardParameter::CHANNEL_ID_ZERO);
+
+  EXPECT_TRUE(can_factory->CreateCANClient(can_card_parameter) != nullptr);
+#endif
 }
 
 }  // namespace canbus
diff --git a/modules/drivers/canbus/can_client/can_client_test.cc b/modules/drivers/canbus/can_client/can_client_test.cc
new file mode 100644
index 0000000..23d9ad9
--- /dev/null
+++ b/modules/drivers/canbus/can_client/can_client_test.cc
@@ -0,0 +1,57 @@
+/******************************************************************************
+ * Copyright 2017 The Apollo Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *****************************************************************************/
+
+#include "modules/drivers/canbus/can_client/axcan/axcan_client.h"
+
+#include <vector>
+
+#include "gtest/gtest.h"
+
+#include "modules/drivers/canbus/proto/can_card_parameter.pb.h"
+
+namespace apollo {
+namespace drivers {
+namespace canbus {
+namespace can {
+
+using apollo::common::ErrorCode;
+
+TEST(AxCanClientTest, simple_test) {
+  CANCardParameter param;
+  param.set_brand(CANCardParameter::AX_CAN);
+  param.set_channel_id(CANCardParameter::CHANNEL_ID_ZERO);
+
+  AxCanClient ax_can_client;
+  EXPECT_TRUE(ax_can_client.Init(param));
+  EXPECT_EQ(ax_can_client.Start(), ErrorCode::CAN_CLIENT_ERROR_BASE);
+  std::vector<CanFrame> frames;
+  int32_t num = 0;
+  EXPECT_EQ(ax_can_client.Send(frames, &num),
+            ErrorCode::CAN_CLIENT_ERROR_SEND_FAILED);
+  EXPECT_EQ(ax_can_client.Receive(&frames, &num),
+            ErrorCode::CAN_CLIENT_ERROR_RECV_FAILED);
+  CanFrame can_frame;
+  frames.push_back(can_frame);
+  EXPECT_EQ(ax_can_client.SendSingleFrame(frames),
+            ErrorCode::CAN_CLIENT_ERROR_SEND_FAILED);
+  ax_can_client.Stop();
+}
+
+}  // namespace can
+}  // namespace canbus
+}  // namespace drivers
+}  // namespace apollo
+
diff --git a/modules/drivers/canbus/proto/can_card_parameter.proto b/modules/drivers/canbus/proto/can_card_parameter.proto
index eb2266b..dfca9a7 100644
--- a/modules/drivers/canbus/proto/can_card_parameter.proto
+++ b/modules/drivers/canbus/proto/can_card_parameter.proto
@@ -9,6 +9,7 @@ message CANCardParameter {
     SOCKET_CAN_RAW = 2;
     HERMES_CAN = 3;
     BF_PUB_ROS1_SUB = 4;
+    AX_CAN = 5;
   }
 
   enum CANCardType {
@@ -28,8 +29,10 @@ message CANCardParameter {
   }
 
   enum CANBaudRate {
-    BAUD_RATE_500 = 0;
-    BAUD_RATE_250 = 1;
+    BAUD_RATE_1000 = 0;
+    BAUD_RATE_500 = 1;
+    BAUD_RATE_250 = 2;
+    BAUD_RATE_150 = 3;
   }
 
   optional CANCardBrand brand = 1;
diff --git a/modules/drivers/radar/conti_radar/conf/conti_radar_front_conf.pb.txt b/modules/drivers/radar/conti_radar/conf/conti_radar_front_conf.pb.txt
index f2a0e6c..171c9d0 100644
--- a/modules/drivers/radar/conti_radar/conf/conti_radar_front_conf.pb.txt
+++ b/modules/drivers/radar/conti_radar/conf/conti_radar_front_conf.pb.txt
@@ -1,7 +1,7 @@
 can_conf {
 
   can_card_parameter {
-    brand:ESD_CAN
+    brand:AX_CAN
     type: PCI_CARD
     channel_id: CHANNEL_ID_ONE
   }
diff --git a/modules/drivers/radar/conti_radar/conf/conti_radar_left_conf.pb.txt b/modules/drivers/radar/conti_radar/conf/conti_radar_left_conf.pb.txt
index c6482c7..0a1bb9e 100644
--- a/modules/drivers/radar/conti_radar/conf/conti_radar_left_conf.pb.txt
+++ b/modules/drivers/radar/conti_radar/conf/conti_radar_left_conf.pb.txt
@@ -1,7 +1,7 @@
 can_conf {
 
   can_card_parameter {
-    brand:ESD_CAN
+    brand:AX_CAN
     type: PCI_CARD
     channel_id: CHANNEL_ID_TWO
   }
diff --git a/modules/drivers/radar/conti_radar/conf/radar_rear_conf.pb.txt b/modules/drivers/radar/conti_radar/conf/radar_rear_conf.pb.txt
index cb3b546..945f2da 100644
--- a/modules/drivers/radar/conti_radar/conf/radar_rear_conf.pb.txt
+++ b/modules/drivers/radar/conti_radar/conf/radar_rear_conf.pb.txt
@@ -1,7 +1,7 @@
 can_conf {
 
   can_card_parameter {
-    brand:HERMES_CAN
+    brand:AX_CAN
     type: PCI_CARD
     channel_id: CHANNEL_ID_TWO
   }
diff --git a/modules/drivers/radar/ultrasonic_radar/conf/ultrasonic_radar_conf.pb.txt b/modules/drivers/radar/ultrasonic_radar/conf/ultrasonic_radar_conf.pb.txt
index 6360110..7b2d1fe 100644
--- a/modules/drivers/radar/ultrasonic_radar/conf/ultrasonic_radar_conf.pb.txt
+++ b/modules/drivers/radar/ultrasonic_radar/conf/ultrasonic_radar_conf.pb.txt
@@ -1,6 +1,6 @@
 can_conf {
   can_card_parameter {
-    brand:ESD_CAN
+    brand:AX_CAN
     type: PCI_CARD
     channel_id: CHANNEL_ID_THREE
   }
diff --git a/modules/monitor/BUILD b/modules/monitor/BUILD
index d34c889..2b90651 100644
--- a/modules/monitor/BUILD
+++ b/modules/monitor/BUILD
@@ -16,7 +16,7 @@ cc_binary(
         "//cyber",
         "//modules/common/util:message_util",
         "//modules/monitor/common:recurrent_runner",
-        "//modules/monitor/hardware:esdcan_monitor",
+        "//modules/monitor/hardware:axcan_monitor",
         "//modules/monitor/hardware:gps_monitor",
         "//modules/monitor/hardware:resource_monitor",
         "//modules/monitor/hardware:socket_can_monitor",
diff --git a/modules/monitor/hardware/BUILD b/modules/monitor/hardware/BUILD
index 5d5aa44..39d99f3 100644
--- a/modules/monitor/hardware/BUILD
+++ b/modules/monitor/hardware/BUILD
@@ -36,9 +36,9 @@ cc_library(
 )
 
 cc_library(
-    name = "esdcan_monitor",
-    srcs = ["esdcan_monitor.cc"],
-    hdrs = ["esdcan_monitor.h"],
+    name = "axcan_monitor",
+    srcs = ["axcan_monitor.cc"],
+    hdrs = ["axcan_monitor.h"],
     copts = [
         '-DMODULE_NAME=\\"monitor\\"',
     ],
@@ -48,8 +48,8 @@ cc_library(
         "//modules/monitor/common:recurrent_runner",
         "//modules/monitor/software:summary_monitor",
     ] + select({
-        "//tools/platforms:use_esd_can": [
-            "//third_party/can_card_library/esd_can",
+        "//tools/platforms:use_ax_can": [
+            "//third_party/can_card_library/axcan",
         ],
         "//conditions:default": [],
     }),
diff --git a/modules/monitor/hardware/axcan_monitor.cc b/modules/monitor/hardware/axcan_monitor.cc
new file mode 100644
index 0000000..17ee0f4
--- /dev/null
+++ b/modules/monitor/hardware/axcan_monitor.cc
@@ -0,0 +1,145 @@
+/******************************************************************************
+ * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *****************************************************************************/
+
+#include "modules/monitor/hardware/axcan_monitor.h"
+
+#include <string>
+
+#if USE_AX_CAN
+#include "axcan/include/axcan.h"
+#endif
+
+#include "cyber/common/log.h"
+#include "modules/common/util/file.h"
+#include "modules/common/util/map_util.h"
+#include "modules/monitor/common/monitor_manager.h"
+#include "modules/monitor/software/summary_monitor.h"
+
+DEFINE_int32(axcan_id, 0, "AXCAN id.");
+DEFINE_string(axcan_monitor_name, "AxCanMonitor", "Name of the CAN monitor.");
+DEFINE_double(axcan_monitor_interval, 3, "CAN status checking interval (s).");
+DEFINE_string(axcan_component_name, "AX-CAN",
+              "Name of the AXCAN component in SystemStatus.");
+
+namespace apollo {
+namespace monitor {
+namespace {
+
+#if USE_AX_CAN
+std::string StatusString(const int ntstatus) {
+  switch (ntstatus) {
+    case AXCAN_OK:
+      return "AXCAN_OK";
+    case AXCAN_DEV_ERR:
+      return "AXCAN_DEV_ERR";
+    case AXCAN_ERR:
+      return "AXCAN_ERR";
+    case AXCAN_PARAM_INVALID:
+      return "AXCAN_PARAM_INVALID";
+    case AXCAN_HDL_INVALID:
+      return "AXCAN_HDL_INVALID";
+    case AXCAN_PARTIAL_OK:
+      return "AXCAN_PARTIAL_OK";
+    case AXCAN_NOT_SUPPORTED:
+      return "AXCAN_NOT_SUPPORTED";
+    default:
+      break;
+  }
+  return "AXCAN_UNKNOWN";
+}
+
+int AxCanTest(const int can_id, AXCAN_HANDLE* handle) {
+  int ret = axcan_open(can_id, 0, 1, 1, handle);
+  if (ret == AXCAN_OK) {
+    AINFO << "Successfully opened AX-CAN device " << can_id;
+  } else {
+    AERROR << "Failed to open AX-CAN device " << can_id << ", error: " << ret
+           << " (" << StatusString(ret) << ")";
+    return ret;
+  }
+
+  ret = axcan_get_state(*handle);
+  if (ret != AXCAN_OK) {
+    AERROR << "Cannot get status of AX-CAN, ret=" << ret << " ("
+           << StatusString(ret) << ")";
+    return ret;
+  }
+
+  ret = axcan_get_stats(*handle);
+  if (ret != AXCAN_OK) {
+    AERROR << "AXCAN_IOCTL_GET_BUS_STATISTIC failed for device with error: "
+           << ret << " (" << StatusString(ret) << ")";
+    return ret;
+  }
+
+  ret = axcan_get_err_counter(*handle, nullptr, nullptr);
+  if (ret != AXCAN_OK) {
+    AERROR << "AXCAN_IOCTL_GET_CTRL_STATUS failed for device with error: "
+           << ret << " (" << StatusString(ret) << ")";
+    return ret;
+  }
+
+  AXCAN_BITRATE bitrate;
+  ret = axcan_get_baudrate(*handle, &bitrate);
+  if (ret != AXCAN_OK) {
+    AERROR << "AXCAN_IOCTL_GET_BITRATE_ for device with error: " << ret << " ("
+           << StatusString(ret) << ")";
+    return ret;
+  }
+  return ret;
+}
+
+void AxCanTest(const int can_id, ComponentStatus* status) {
+  AXCAN_HANDLE handle;
+  const int ret = AxCanTest(can_id, &handle);
+  axcan_close(handle);
+
+  SummaryMonitor::EscalateStatus(
+      ret == AXCAN_OK ? ComponentStatus::OK : ComponentStatus::ERROR,
+      StatusString(ret), status);
+}
+#else
+// USE_AX_CAN is not set, do dummy check.
+void AxCanTest(const int can_id, ComponentStatus* status) {
+  SummaryMonitor::EscalateStatus(ComponentStatus::ERROR,
+                                 "USE_AX_CAN is not defined during compiling",
+                                 status);
+}
+#endif
+
+}  // namespace
+
+AxCanMonitor::AxCanMonitor()
+    : RecurrentRunner(FLAGS_axcan_monitor_name,
+                      FLAGS_axcan_monitor_interval) {}
+
+void AxCanMonitor::RunOnce(const double current_time) {
+  Component* component = apollo::common::util::FindOrNull(
+      *MonitorManager::Instance()->GetStatus()->mutable_components(),
+     FLAGS_axcan_component_name);
+  if (component == nullptr) {
+    // Canbus is not monitored in current mode, skip.
+    return;
+  }
+
+  auto* status = component->mutable_other_status();
+  status->clear_status();
+  AxCanTest(FLAGS_axcan_id, status);
+}
+
+}  // namespace monitor
+}  // namespace apollo
+
diff --git a/modules/monitor/hardware/axcan_monitor.h b/modules/monitor/hardware/axcan_monitor.h
new file mode 100644
index 0000000..79b5f43
--- /dev/null
+++ b/modules/monitor/hardware/axcan_monitor.h
@@ -0,0 +1,30 @@
+/******************************************************************************
+ * Copyright 2018 The Apollo Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *****************************************************************************/
+#pragma once
+
+#include "modules/monitor/common/recurrent_runner.h"
+
+namespace apollo {
+namespace monitor {
+
+class AxCanMonitor : public RecurrentRunner {
+ public:
+  AxCanMonitor();
+  void RunOnce(const double current_time) override;
+};
+
+}  // namespace monitor
+}  // namespace apollo
diff --git a/modules/monitor/monitor.cc b/modules/monitor/monitor.cc
index 2b119fb..0e530a4 100644
--- a/modules/monitor/monitor.cc
+++ b/modules/monitor/monitor.cc
@@ -17,7 +17,11 @@
 
 #include "modules/common/time/time.h"
 #include "modules/monitor/common/monitor_manager.h"
+#if USE_AX_CAN
+#include "modules/monitor/hardware/axcan_monitor.h"
+#else
 #include "modules/monitor/hardware/esdcan_monitor.h"
+#endif
 #include "modules/monitor/hardware/gps_monitor.h"
 #include "modules/monitor/hardware/resource_monitor.h"
 #include "modules/monitor/hardware/socket_can_monitor.h"
@@ -46,7 +50,11 @@ bool Monitor::Init() {
   MonitorManager::Instance()->Init(node_);
 
   // Only the one CAN card corresponding to current mode will take effect.
+#if USE_AX_CAN
+  runners_.emplace_back(new AxCanMonitor());
+#else
   runners_.emplace_back(new EsdCanMonitor());
+#endif
   runners_.emplace_back(new SocketCanMonitor());
   // To enable the GpsMonitor, you must add FLAGS_gps_component_name to the
   // mode's monitored_components.
diff --git a/modules/tools/py_axcan_interface/README.md b/modules/tools/py_axcan_interface/README.md
new file mode 100644
index 0000000..3aa6121
--- /dev/null
+++ b/modules/tools/py_axcan_interface/README.md
@@ -0,0 +1,14 @@
+## What is this
+This is a interface. It can be used in python script via calling axcan c++ api. So you can use axcan in python script.
+
+
+## How to use
+`py-ax-can-interface` folder is the package. You should copy the folder when you want to use it in other place.
+This package can be used in ubuntu(out of docker) or in docker.
+
+see `example.py`
+
+If display error `open device error code [19]: AXCAN_NET_NOT_FOUND - CAN device not present` when `import ax_can` in python.
+Run
+`bash setup_once.sh`
+Just only once.
diff --git a/modules/tools/py_axcan_interface/can_receive.py b/modules/tools/py_axcan_interface/can_receive.py
new file mode 100644
index 0000000..f4a086e
--- /dev/null
+++ b/modules/tools/py_axcan_interface/can_receive.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+
+import time
+import ax_can as ax
+
+port = ax.CHANNEL_ID_ONE
+baud_rate = ax.BAUD_RATE_500
+my_can = ax.AxCanClient(port, baud_rate)
+
++while True:
+    my_receive = my_can.Receive(10)  # Receive can message, max num is 10
+    for i in range(len(my_receive)):
+        tmp_id = my_receive[i].id
+        tmp_len = my_receive[i].len
+        tmp_data = my_receive[i].data
+        tmp_data_str = ''
+        for j in range(tmp_len):
+            tmp_data[j] = str(hex(tmp_data[j]))
+            tmp_data[j] = tmp_data[j][2:]
+            if len(tmp_data[j]) == 1:
+                tmp_data[j] = '0' + tmp_data[j]
+            tmp_data_str += tmp_data[j]
+        tmp_id_str = str(hex(tmp_id))
+        tmp_id_str = tmp_id_str[2:]
+        new_time = time.time()
+        while len(tmp_id_str) < 3:
+            tmp_id_str = '0' + tmp_id_str
+        print('(%.6f) can0 '%new_time, tmp_id_str, '#', tmp_data_str, sep='')
+
diff --git a/modules/tools/py_axcan_interface/example.py b/modules/tools/py_axcan_interface/example.py
new file mode 100644
index 0000000..a38761e
--- /dev/null
+++ b/modules/tools/py_axcan_interface/example.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python3
+
+"""
+How to use
+
+import ax_can as ax
+my_can = ax.AxCanClient()  # default port = ax.CHANNEL_ID_ZERO, baud_rate = ax.BAUD_RATE_500
+
+port = ax.CHANNEL_ID_ONE
+baud_rate = ax.BAUD_RATE_500
+my_can = ax.AxCanClient(port, baud_rate) # use CHANNEL_ID_ONE, BAUD_RATE_500
+
+frame = ax.CanFrame() # default frame.id = 0, frame.len = 0 , frame.data = [0,0,0,0,0,0,0,0]
+frame.id = 0x61
+frame.len = 4
+frame.data = [5,5,5,5,0,0,0,0]
+
+frame = ax.CanFrame(0x60, 8, [1,2,3,4,5,6,7,8]) # frame.id = 96, frame.len = 8 , frame.data = [1,2,3,4,5,6,7,8]
+
+frame_list = []
+frame_list.append(frame)
+
+my_can.Send(frame_list, len(frame_list))  # Send can message, max num is 10
+my_can.Send([frame], 1)  # Send can message, max num is 10
+
+message_list = my_can.Receive(1)  # Receive can message, max num is 10
+
+Notes:
+MAX_CAN_SEND_FRAME_LEN = 10;
+MAX_CAN_RECV_FRAME_LEN = 10;
+"""
+
+"""
+c data structure
+
+enum CANChannelId {
+  CHANNEL_ID_ZERO = 0,
+  CHANNEL_ID_ONE = 1,
+  CHANNEL_ID_TWO = 2,
+  CHANNEL_ID_THREE = 3
+};
+
+enum CANBaudRate {
+  BAUD_RATE_500 = 0,
+  BAUD_RATE_250 = 1
+};
+
+struct CanFrame {
+  uint32_t id;
+  uint8_t len;
+  std::array<uint8_t, 8> data;
+}
+
+AxCanClient::Send(const std::vector<CanFrame> &frames, int32_t num);
+std::vector<CanFrame> AxCanClient::Receive(int32_t num);
+"""
+
+import time
+import ax_can as ax
+
+port = ax.CHANNEL_ID_ZERO
+baud_rate = ax.BAUD_RATE_500
+my_can = ax.AxCanClient(port, baud_rate) # use CHANNEL_ID_ONE, BAUD_RATE_500
+
+frame_list = []
+
+frame = ax.CanFrame(0x60, 8, [1,2,3,4,5,6,7,8]) # frame.id = 96, frame.len = 8 , frame.data = [1,2,3,4,5,6,7,8]
+frame_list.append(frame)
+
+frame = ax.CanFrame() # default frame.id = 0, frame.len = 0 , frame.data = [0,0,0,0,0,0,0,0]
+frame.id = 0x61
+frame.len = 4
+frame.data = [0x5,0x5,0x5,0x5,0,0,0,0]
+frame_list.append(frame)
+
+my_can.Send(frame_list, len(frame_list))  # Send can message, max num is 10
+my_can.Send([frame], 1)
+
+old_time = time.time()
+new_time = time.time()
+
+print('Receive start:')
+while new_time - old_time < 5:
+	my_receive = my_can.Receive(10)  # Receive can message, max num is 10
+	for i in range(len(my_receive)):
+		print('id:', my_receive[i].id, ' len:', my_receive[i].len, ' data:', my_receive[i].data)
+	new_time = time.time()
+print('Receive end.')
+
diff --git a/modules/tools/py_axcan_interface/setup_once.sh b/modules/tools/py_axcan_interface/setup_once.sh
new file mode 100644
index 0000000..89d1279
--- /dev/null
+++ b/modules/tools/py_axcan_interface/setup_once.sh
@@ -0,0 +1,18 @@
+#!/usr/bin/env bash
+
+# How to use:
+# If display error "open device error code [19]: AXCAN_NET_NOT_FOUND - CAN device not present"
+# when "import ax_can" in python.
+# Run "bash setup_once.sh", Just only once.
+
+for INDEX in `seq 0 5`
+do
+  # soft link if sensorbox exist
+ if [ -e /dev/cash_can${INDEX} ] &&  [ ! -e /dev/can${INDEX} ]; then
+    sudo ln -s /dev/cash_can${INDEX} /dev/can${INDEX}
+  fi
+  if [ ! -e /dev/can${INDEX} ]; then
+    sudo mknod --mode=a+rw /dev/can${INDEX} c 2020 $INDEX
+  fi
+done
+
diff --git a/run.sh b/run.sh
index 6f0727b..7357ad5 100755
--- a/run.sh
+++ b/run.sh
@@ -128,6 +128,20 @@ function check_esd_files() {
   fi
 }
 
+function check_axcan_files() {
+  CAN_CARD="fake_can"
+
+  if [ -f ./third_party/can_card_library/axcan/include/axcan.h ] && \
+      [ -f ./third_party/can_card_library/axcan/lib/libaxcan.so ]; then
+      USE_AX_CAN=true
+      CAN_CARD="ax_can"
+  else
+      warning "AXCAN library does not exist. Please refer to third_party/can_card_library/axcan/README.md."
+      USE_AX_CAN=false
+  fi
+}
+
+
 # Copy perception configs to current_configs (previously copied by cmake function)
 function copy_configs() {
   local _current_configs_path="/apollo/current_configs/"
@@ -188,8 +202,8 @@ function generate_build_targets() {
   if [ $? -ne 0 ]; then
     fail 'Build failed!'
   fi
-  if ! $USE_ESD_CAN; then
-     BUILD_TARGETS=$(echo "$BUILD_TARGETS" |tr ' ' '\n' | grep -v "esd")
+  if ! $USE_AX_CAN; then
+     BUILD_TARGETS=$(echo "$BUILD_TARGETS" |tr ' ' '\n' | grep -v "axcan")
   fi
   #skip msf for non x86_64 platforms
   if [ "${MACHINE_ARCH}" != "x86_64" ]; then
@@ -612,6 +626,7 @@ function release() {
     warn_proprietary_sw
   fi
   cp -a third_party/can_card_library/esd_can/lib/* "$LIB_DIR"
+  cp -a third_party/can_card_library/axcan/lib/* "$LIB_DIR"
   cp -a modules/canbus/vehicle/byd/protocol/lib/* "$LIB_DIR"
   cp -a third_party/can_card_library/hermes_can/lib/* "$LIB_DIR"
   cp -a third_party/rss/lib/* "$LIB_DIR"
@@ -1118,9 +1133,9 @@ function print_usage() {
 function main() {
   source_xurban_base
   apollo_check_system_config
-  check_esd_files
+  check_axcan_files
 
-  DEFINES="--define ARCH=${MACHINE_ARCH} --define CAN_CARD=${CAN_CARD} --cxxopt=-DUSE_ESD_CAN=${USE_ESD_CAN}"
+  DEFINES="--define ARCH=${MACHINE_ARCH} --define CAN_CARD=${CAN_CARD} --cxxopt=-DUSE_AX_CAN=${USE_AX_CAN}"
 
   if [ "${MACHINE_ARCH}" == "x86_64" ]; then
     DEFINES="${DEFINES} --copt=-mavx2"
diff --git a/seamake/embedded/dbw_mkz/steer_boot/Tools/py_axcan_interface/README.md b/seamake/embedded/dbw_mkz/steer_boot/Tools/py_axcan_interface/README.md
new file mode 100644
index 0000000..3aa6121
--- /dev/null
+++ b/seamake/embedded/dbw_mkz/steer_boot/Tools/py_axcan_interface/README.md
@@ -0,0 +1,14 @@
+## What is this
+This is a interface. It can be used in python script via calling axcan c++ api. So you can use axcan in python script.
+
+
+## How to use
+`py-ax-can-interface` folder is the package. You should copy the folder when you want to use it in other place.
+This package can be used in ubuntu(out of docker) or in docker.
+
+see `example.py`
+
+If display error `open device error code [19]: AXCAN_NET_NOT_FOUND - CAN device not present` when `import ax_can` in python.
+Run
+`bash setup_once.sh`
+Just only once.
diff --git a/seamake/embedded/dbw_mkz/steer_boot/Tools/py_axcan_interface/setup_once.sh b/seamake/embedded/dbw_mkz/steer_boot/Tools/py_axcan_interface/setup_once.sh
new file mode 100644
index 0000000..89d1279
--- /dev/null
+++ b/seamake/embedded/dbw_mkz/steer_boot/Tools/py_axcan_interface/setup_once.sh
@@ -0,0 +1,18 @@
+#!/usr/bin/env bash
+
+# How to use:
+# If display error "open device error code [19]: AXCAN_NET_NOT_FOUND - CAN device not present"
+# when "import ax_can" in python.
+# Run "bash setup_once.sh", Just only once.
+
+for INDEX in `seq 0 5`
+do
+  # soft link if sensorbox exist
+ if [ -e /dev/cash_can${INDEX} ] &&  [ ! -e /dev/can${INDEX} ]; then
+    sudo ln -s /dev/cash_can${INDEX} /dev/can${INDEX}
+  fi
+  if [ ! -e /dev/can${INDEX} ]; then
+    sudo mknod --mode=a+rw /dev/can${INDEX} c 2020 $INDEX
+  fi
+done
+
diff --git a/third_party/can_card_library/axcan/BUILD b/third_party/can_card_library/axcan/BUILD
new file mode 100644
index 0000000..3d94c6f
--- /dev/null
+++ b/third_party/can_card_library/axcan/BUILD
@@ -0,0 +1,15 @@
+package(default_visibility = ["//visibility:public"])
+
+licenses(["notice"])
+
+cc_library(
+    name = "axcan",
+    srcs = [
+        "lib/libaxcan.so",
+    ],
+    hdrs = [
+        "include/axcan.h",
+    ],
+    include_prefix = "axcan",
+)
+
diff --git a/third_party/can_card_library/axcan/README.md b/third_party/can_card_library/axcan/README.md
new file mode 100644
index 0000000..de1a54f
--- /dev/null
+++ b/third_party/can_card_library/axcan/README.md
@@ -0,0 +1,4 @@
+After unpacking the software package platsw, please find and copy the following files to the specific sub-directories (under this directory):
+   * Copy axcan.h to include/
+   * Copy 64-bit libaxcan.so to third_party/can_card_library/axcan/lib/
+
diff --git a/third_party/can_card_library/axcan/include/axcan.h b/third_party/can_card_library/axcan/include/axcan.h
new file mode 100644
index 0000000..e02ae83
--- /dev/null
+++ b/third_party/can_card_library/axcan/include/axcan.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2020 AutoX, Inc.
+ */
+
+#ifndef __AAXCAN_API_H__
+#define __AAXCAN_API_H__
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define AXCAN_EXTENDED_FRAME 0x20000000
+#define AXCAN_20B_BASE 0x20000000
+
+#define AXCAN_MAX_DEV 6
+#define AXCAN_MAX_BULK_MSG 64
+#define AXCAN_MAX_TX_MSG (AXCAN_MAX_BULK_MSG * 1)
+#define AXCAN_MAX_RX_MSG 16384
+
+/* Channel states */
+#define AXCAN_DEV_UNINIT -1
+#define AXCAN_DEV_OPEN (1 << 0)
+#define AXCAN_DEV_CLOSE (1 << 1)
+#define AXCAN_DEV_BAUD_SET (1 << 2)
+#define AXCAN_DEV_NORMAL (1 << 3)
+#define AXCAN_DEV_LOOPBACK (1 << 4)
+#define AXCAN_DEV_CONFIG (1 << 5)
+#define AXCAN_DEV_START (1 << 6)
+#define AXCAN_DEV_STOP (1 << 7)
+#define AXCAN_DEV_ACTIVE (1 << 8)
+#define AXCAN_DEV_RECVD (1 << 9)
+
+typedef uint64_t AXCAN_CTRL_STATE;
+typedef uint64_t AXCAN_BUS_STATISTIC;
+typedef uint64_t CAN_IF_STATUS;
+typedef uint64_t axcan_hdl_t;
+typedef axcan_hdl_t AXCAN_HANDLE;
+extern uint64_t unknown_qevent[AXCAN_MAX_DEV];
+
+/*
+ * AXCAN message definition
+ */
+typedef struct axcan_msg {
+  uint32_t id; /* AXCAN-ID (11-/29-bit) or Event-ID        [Tx, Rx] */
+  uint8_t len; /* Bit 0-3 = Data Length Code             [Tx, Rx] */
+  /* Bit 4   = RTR (Classical AXCAN)          [Tx, Rx] */
+  /*         = No_BRS (AXCAN FD)              [Tx, Rx] */
+  /* Bit 5   = No_Data (Object Mode)        [    Rx] */
+  /*         = Interaction Data (FIFO Mode)          */
+  /* Bit 6   = Reserved                     [Tx, Rx] */
+  /* Bit 7   = Type(AXCAN FD / Classical AXCAN) [Tx, Rx] */
+  uint8_t msg_lost; /* counter for lost Rx messages */
+  uint8_t reserved[2];
+  uint8_t data[8];           /* 8 data-bytes */
+  struct timespec timestamp; /* timestamp of this message */
+} axcan_msg_t;
+
+/*
+ * AXCAN error code
+ */
+enum axcan_err_code {
+  AXCAN_PARAM_INVALID = -12,
+  AXCAN_HDL_INVALID,
+  AXCAN_DEV_INVALID,
+  AXCAN_DEV_ERR,
+  AXCAN_DEV_BUSY,
+  AXCAN_TIMEOUT,
+  AXCAN_FAIL,
+  AXCAN_NOT_SUPPORTED,
+  AXCAN_NOT_IMPLEMENTED,
+  AXCAN_INVALID,
+  AXCAN_NO_BUFFERS,
+  AXCAN_ERR,
+  AXCAN_OK, /* 0 */
+  AXCAN_PARTIAL_OK,
+  AXCAN_RX_TIMEOUT,
+  AXCAN_TX_TIMEOUT,
+  AXCAN_TX_ERROR,
+  AXCAN_CONTR_OFF_BUS,
+  AXCAN_CONTR_BUSY,
+  AXCAN_CONTR_NO_ID_ENABLED,
+  AXCAN_ID_ALREADY_ENABLED,
+  AXCAN_ID_NOT_ENABLED,
+  AXCAN_MESSAGE_LOST,
+};
+
+/*
+ * CAN operational and error states
+ */
+enum axcan_state {
+  AXCAN_STATE_ERROR_ACTIVE = 0,	/* RX/TX error count < 96 */
+  AXCAN_STATE_ERROR_WARNING,	/* RX/TX error count < 128 */
+  AXCAN_STATE_ERROR_PASSIVE,	/* RX/TX error count < 256 */
+  AXCAN_STATE_BUS_OFF,		/* RX/TX error count >= 256 */
+  AXCAN_STATE_STOPPED,		/* Device is stopped */
+  AXCAN_STATE_SLEEPING,		/* Device is sleeping */
+  AXCAN_STATE_MAX
+};
+
+/*
+ * CAN device statistics
+ */
+struct axcan_device_stats {
+  uint32_t bus_error;	/* Bus errors */
+  uint32_t error_warning;	/* Changes to error warning state */
+  uint32_t error_passive;	/* Changes to error passive state */
+  uint32_t bus_off;		/* Changes to bus off state */
+  uint32_t arbitration_lost; /* Arbitration lost errors */
+  uint32_t restarts;		/* CAN controller re-starts */
+};
+
+
+typedef enum axcan_baudrate_t {
+  AXCAN_BAUDRATE_1M,
+  AXCAN_BAUDRATE_500K,
+  AXCAN_BAUDRATE_250K,
+  AXCAN_BAUDRATE_150K,
+  AXCAN_BAUDRATE_NUM
+} AXCAN_BITRATE;
+
+/* Returns can library version. */
+const char *axcan_get_libversion(void);
+
+/* Returns error message corresponding to the given error code. */
+const char *axcan_get_err_msg(int err_code);
+
+int axcan_test(axcan_hdl_t hdl);
+int axcan_open(uint32_t dev_index, uint32_t flags, 
+             uint64_t tx_to, uint64_t rx_to, axcan_hdl_t *hdl);
+int axcan_close(axcan_hdl_t hdl);
+int axcan_start(axcan_hdl_t hdl);
+int axcan_stop(axcan_hdl_t hdl);
+int axcan_reset(axcan_hdl_t hdl);
+int axcan_id_add(axcan_hdl_t hdl, uint32_t id);
+int axcan_id_del(axcan_hdl_t hdl, uint32_t id);
+int axcan_get_stats(axcan_hdl_t hdl);
+int axcan_clear_stats(axcan_hdl_t hdl);
+int axcan_set_loopback(axcan_hdl_t hdl);
+int axcan_unset_loopback(axcan_hdl_t hdl);
+int axcan_set_baudrate(axcan_hdl_t hdl, enum axcan_baudrate_t rate);
+int axcan_get_baudrate(axcan_hdl_t hdl, enum axcan_baudrate_t *rate);
+int axcan_recv(axcan_hdl_t hdl, axcan_msg_t *buf, int32_t num_msg);
+int axcan_send(axcan_hdl_t hdl, axcan_msg_t *buf, int32_t num_msg);
+int axcan_send_hi_pri(axcan_hdl_t hdl, axcan_msg_t *buf);
+int axcan_get_state(axcan_hdl_t hdl);
+int axcan_dump_debug_regs(axcan_hdl_t hdl);
+int axcan_get_err_counter(axcan_hdl_t hdl, uint8_t *rx_err, uint8_t *tx_err);
+int axcan_trigger_dummy(uint32_t dev_index);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __AAXCAN_API_H__ */
diff --git a/third_party/can_card_library/axcan/lib/libaxcan-debug.a b/third_party/can_card_library/axcan/lib/libaxcan-debug.a
new file mode 100644
index 0000000..708fe41
Binary files /dev/null and b/third_party/can_card_library/axcan/lib/libaxcan-debug.a differ
diff --git a/third_party/can_card_library/axcan/lib/libaxcan-debug.so b/third_party/can_card_library/axcan/lib/libaxcan-debug.so
new file mode 100755
index 0000000..8a195cf
Binary files /dev/null and b/third_party/can_card_library/axcan/lib/libaxcan-debug.so differ
diff --git a/third_party/can_card_library/axcan/lib/libaxcan-perf.a b/third_party/can_card_library/axcan/lib/libaxcan-perf.a
new file mode 100644
index 0000000..f56f524
Binary files /dev/null and b/third_party/can_card_library/axcan/lib/libaxcan-perf.a differ
diff --git a/third_party/can_card_library/axcan/lib/libaxcan-perf.so b/third_party/can_card_library/axcan/lib/libaxcan-perf.so
new file mode 100755
index 0000000..594f551
Binary files /dev/null and b/third_party/can_card_library/axcan/lib/libaxcan-perf.so differ
diff --git a/third_party/can_card_library/axcan/lib/libaxcan.a b/third_party/can_card_library/axcan/lib/libaxcan.a
new file mode 120000
index 0000000..82a0289d
--- /dev/null
+++ b/third_party/can_card_library/axcan/lib/libaxcan.a
@@ -0,0 +1 @@
+libaxcan-debug.a
\ No newline at end of file
diff --git a/third_party/can_card_library/axcan/lib/libaxcan.so b/third_party/can_card_library/axcan/lib/libaxcan.so
new file mode 120000
index 0000000..0e285f4
--- /dev/null
+++ b/third_party/can_card_library/axcan/lib/libaxcan.so
@@ -0,0 +1 @@
+libaxcan-debug.so
\ No newline at end of file
diff --git a/tools/platforms/BUILD b/tools/platforms/BUILD
index f1add9c..7453bf5 100644
--- a/tools/platforms/BUILD
+++ b/tools/platforms/BUILD
@@ -24,8 +24,8 @@ config_setting(
 )
 
 config_setting(
-    name = "use_esd_can",
+    name = "use_ax_can",
     values = {
-        "define": "CAN_CARD=esd_can",
+        "define": "CAN_CARD=ax_can",
     },
 )
